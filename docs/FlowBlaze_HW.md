# FlowBlaze

**FlowBlaze** implements a reconfigurable stateful dataplane, based on a pipeline of components. This prototype processes the network packets at line rate with minimum delay.

The design is composed of these modules:

* Input/Output signals
* Controller 
* Conditions module
* Look-up/Update Extractor
* Flow Context Table 
* State Table
* EFSM Table 
* Pipealu
* Delay Queue
* Action Block

![FlowBlaze](/docs/img/flowblaze.png)

## Input/Output signals
**FlowBlaze** is composed of three buses S0_AXIS, M0_AXIS and S_AXI. The first two are based on the AXI4_stream protocol while the last one implementeds AXI4_lite protocol. The S0_AXIS bus sends the packets from the input queue to the **FlowBlaze** module while M0_AXIS sends the processed packets to the output queue. S_AXIS bus allows the configuration to the user.

## Controller
When the packet arrives in the module, it activates a state machine to manage the pipeline control. It is composed of four state (IDLE, PKT1, PKT2, WAIT5). The ***IDLE*** state extracts the fields to be processed from the first 256-bit frame. The ***PKT1*** state collects the fileds to be processed by the second 256-bit frame. Then, we define ***PKT2 and WAIT5*** as buffer states to wait for the end of the reception. Finally, the controller deals with the synchronization of the system flow.

## Conditions module
The **Conditions module** is devoted to condition evaluations. It is user programmable, so that it can select which fields of the packets or registers to evaluate. In particular, configuration registers have been inserted in which we can write the field offset and the operation to be done. This module was designed to calculate four parallel operations. GR0-GR3, R1-R3 and O1-O3 are the registers on which to evaluate the conditions. The CR1-CR7 have been inserted to allow the user to program the conditions. The value relating to the register selection is entered in the first two bytes, while the opcode of the codition is written in the third byte. The output is a ***conditions*** vector where each bit rapresents the condition check.

![Conditions module](/docs/img/conditions.png)      

## Look-up/Update Extractor
The **Look-up extractor** and **Update extractor** keys are generated by combining two basic operations: the first operation selects the header, the second operation is the configuration of the 128-bit mask. Two registers are inserted to configure the two operations. The **Barrel shifter** is used to locate the header, it takes the first 320 bits of the packet and generate 128 contiguous bits based on the offset. The mask operation is simply the bitwise between barrel shifter output and mask register to generate the flow key.

![Look-up/Update Extractor](/docs/img/lookup_update.png)

## Flow Context Table
The **Flow Context Table** is implemented with a **Cuckoo Hash Table**. It is mainly built on two subsystems, which are true hash table and a supporting memory called stash. The **stash** serves to hide the variable insertion delay at **FlowBlaze** and reduce the collision events. The **Hash Table** is implemented with four parallel tables. Each table is constructed with a double port **SRAM** to support two inputs, for writing and reading functions in the same clock cycle. From the key, generated by the extractor, four addresses are generated, using a hash function. These are used as **hash table** addresses. The **Hash Table** is coupled with a stash, which supports 8 entries to guarantee a costant insertion time (1 clock cycle). In parallel, there is a logic that moves the entries between the two subsystems.

## State Table
When a new flow arrives in the system, so that the system is not blocking, the **State Table** works in parallel to the cuckoo, to provide the new flow status in case of a miss in the hash table. It is mainly built on two modules, a **TCAM1** and a **RAM1**. The look-up key is also sent to the **State Table**, which looks up in the **TCAM1**. In case of positive match, it returns an address that is sent to the **RAM1** to recover the state of the flow. The **TCAM1** entries consist of 32 128-bit words, while **RAM1** stores 32 32-bit words. The use of small TCAMs is due to the fact that as number of words increases, the working frequency decreases. In fact, the perfomance obtainable by a TCAM on an FPGA is very far away, in terms of size and clock frequency, from that obtainable on an ASIC-type implementation.      

## EFSM Table
The **EFSM Table** has been implemented through a TCAM module and four RAM modules. This choice allows to obtain the maximum degree of flexibility, guaranteeing a costant clock cycle to make the transitions. The TCAM entries are 128 160-bit words, while the RAMs are implemented by 128 64-bit words, where the *next_state, the actions and the action values* are stored. The operation is the same as the ***State Table***. The output, of the ***Cuckoo Hash Table*** or ***State Table*** is sent to the TCAM, where if the match is positive, sends an address to the RAM which return *next_state,action and action value* to process the packet.    
      
## PipeAlu
The **PipeAlu** module can be identified as a parallel arithmetic logical unit used to calculate arithmetic operations, capable of operating on multiple inputs.
The **PipeAlu** consists of a RAM memory that receives the instruction at the input and returns the command to be executed. It is preloaded with all the opcodes that configure the system. This module is structured as an array in which three stages can be identified, which implement a pipeline capable of performing arithmetic operations in each clockcycle with a continuous flow. In particular, the system is able to generate, after passing the transient, an output per clock cycle, which will be subsequently stored in the global registers or in the flow registers, allowing the system to take advantage of this value for subsequent flows. Each stage is implemented through MUX and ALU modules.

In particular, the structure of the PipeALU is the following:

* Stage 1; it is built on four parallel ALUs.
* Stage 2; unlike the first, eight MUXs have been entered at the input. They select whether to trasfer the results of the previous stage to the current stage or trasfer the values at the module input. After MUXes, four ALUs were inserted to perform parallel arithmetic operations, providing the results to the next stage.
* Stage 3: Like the second stage, it consists of eight MUXes. However, unlike the second, eight ALUs generate two types of outputs: the outputs relating to the flow registers and the outputs relating to the global registers.
![PipeAlu](/docs/img/pipealu.png)

To isolate individual opcodes, shift registers have been adopted.

![Shift register](/docs/img/shift_register.png)

## Delay Queue
This module is a 10 cycle clock shift register needed to apply a delay to the packets.

## Action Block
The Action Block performs the actions on the packets and it is divided in two submodules:
* *if modify* This component modifies the output interface in two ways: by inserting the interface stored in RAM3 or by inserting the value present in the reg_test0 register. 
* *Add_field/modify_field* these modules can insert fields in data packets. The *EFSM Table* provides the dimension and position (offset) of the field to be inserted. 
NOTE WELL: the ***modify_field*** changes a field already present in the packet, while ***Add_field*** adds a new field in the packet.
At the end of module a MUX can select the modified packet or the original packet present in the **Delay Queue** to be sent to the output. 
